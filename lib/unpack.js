// Generated by IcedCoffeeScript 1.4.0c
(function() {
  var Buffer, C, U32MAX, Unpacker, floats, modes, pow2, twos_compl_inv, _ref;

  C = require('./const').C;

  Buffer = require('./buffer').Buffer;

  _ref = require('./util'), pow2 = _ref.pow2, twos_compl_inv = _ref.twos_compl_inv, U32MAX = _ref.U32MAX;

  floats = require('./floats');

  modes = {
    NONE: 0,
    BINARY: 1,
    START: 2
  };

  exports.Unpacker = Unpacker = (function() {

    function Unpacker() {
      this._buffer = null;
      this._e = [];
      this._w = [];
    }

    Unpacker.prototype.decode = function(s, enc) {
      return !!(this._buffer = Buffer.decode(s, enc));
    };

    Unpacker.prototype.u_bytes = function(n, mode) {
      var raw, warning, _ref1;
      _ref1 = mode === modes.BINARY ? this._buffer.consume_byte_array(n) : this._buffer.consume_utf8_string(n), warning = _ref1[0], raw = _ref1[1];
      if (warning != null) this._w.push(warning);
      return raw;
    };

    Unpacker.prototype.get_error = function() {
      if (this._e.length) {
        return this._e;
      } else {
        return null;
      }
    };

    Unpacker.prototype.get_warning = function() {
      if (this._w.length) {
        return this._w;
      } else {
        return null;
      }
    };

    Unpacker.prototype.u_array = function(n) {
      var i, _i, _results;
      _results = [];
      for (i = _i = 0; 0 <= n ? _i < n : _i > n; i = 0 <= n ? ++_i : --_i) {
        _results.push(this.u());
      }
      return _results;
    };

    Unpacker.prototype.u_map = function(n) {
      var i, ret, _i;
      ret = {};
      for (i = _i = 0; 0 <= n ? _i < n : _i > n; i = 0 <= n ? ++_i : --_i) {
        ret[this.u()] = this.u();
      }
      return ret;
    };

    Unpacker.prototype.u_uint8 = function() {
      return this._buffer.consume_byte();
    };

    Unpacker.prototype.u_int8 = function() {
      return twos_compl_inv(this.u_uint8(), 8);
    };

    Unpacker.prototype.u_uint16 = function() {
      var v;
      v = this._buffer.consume_bytes(2);
      return v[0] << 8 | v[1];
    };

    Unpacker.prototype.u_int16 = function() {
      return twos_compl_inv(this.u_uint16(), 16);
    };

    Unpacker.prototype.u_uint32 = function() {
      var b, i, sum, v, _i, _len;
      v = this._buffer.consume_bytes(4);
      sum = 0;
      for (i = _i = 0, _len = v.length; _i < _len; i = ++_i) {
        b = v[i];
        sum += b * pow2(8 * (3 - i));
      }
      return sum;
    };

    Unpacker.prototype.u_int32 = function() {
      return twos_compl_inv(this.u_uint32(), 32);
    };

    Unpacker.prototype.u_uint64 = function() {
      return (this.u_uint32() * U32MAX) + this.u_uint32();
    };

    Unpacker.prototype.u_double = function() {
      var cnv;
      cnv = floats.Converter.make(this._buffer);
      if (cnv != null) {
        return cnv.consume_float64();
      } else {
        return this.error("Sorry, no float64 decoding support");
      }
    };

    Unpacker.prototype.u_float = function() {
      var cnv;
      cnv = floats.Converter.make(this._buffer);
      if (cnv != null) {
        return cnv.consume_float32();
      } else {
        return this.error("Sorry, no float32 decoding support");
      }
    };

    Unpacker.prototype.u_int64 = function() {
      var a, b, i, _ref1;
      _ref1 = (function() {
        var _i, _results;
        _results = [];
        for (i = _i = 0; _i < 2; i = ++_i) {
          _results.push(this.u_uint32());
        }
        return _results;
      }).call(this), a = _ref1[0], b = _ref1[1];
      return U32MAX * (a - U32MAX) + b;
    };

    Unpacker.prototype.error = function(e) {
      this._e.push(e);
      return null;
    };

    Unpacker.prototype.u_inner = function(last_mode) {
      var b, l, mode, ret;
      mode = modes.NONE;
      b = this._buffer.consume_byte();
      ret = (function() {
        if (b <= C.positive_fix_max) {
          return b;
        } else if (b >= C.negative_fix_min && b <= C.negative_fix_max) {
          return twos_compl_inv(b, 8);
        } else if (b >= C.fix_raw_min && b <= C.fix_raw_max) {
          l = b & C.fix_raw_count_mask;
          return this.u_bytes(l, last_mode);
        } else if (b >= C.fix_array_min && b <= C.fix_array_max) {
          l = b & C.fix_array_count_mask;
          return this.u_array(l);
        } else if (b >= C.fix_map_min && b <= C.fix_map_max) {
          l = b & C.fix_map_count_mask;
          return this.u_map(l);
        } else if (b === C.byte_array) {
          mode = modes.BINARY;
          return null;
        } else {
          switch (b) {
            case C["null"]:
              return null;
            case C["true"]:
              return true;
            case C["false"]:
              return false;
            case C.uint8:
              return this.u_uint8();
            case C.uint16:
              return this.u_uint16();
            case C.uint32:
              return this.u_uint32();
            case C.uint64:
              return this.u_uint64();
            case C.int8:
              return this.u_int8();
            case C.int16:
              return this.u_int16();
            case C.int32:
              return this.u_int32();
            case C.int64:
              return this.u_int64();
            case C.double:
              return this.u_double();
            case C.float:
              return this.u_float();
            case C.raw16:
              return this.u_bytes(this.u_uint16(), last_mode);
            case C.raw32:
              return this.u_bytes(this.u_uint32(), last_mode);
            case C.array16:
              return this.u_array(this.u_uint16());
            case C.array32:
              return this.u_array(this.u_uint32());
            case C.map16:
              return this.u_map(this.u_uint16());
            case C.map32:
              return this.u_map(this.u_uint32());
            default:
              return this.error("unhandled type " + b);
          }
        }
      }).call(this);
      return [mode, ret];
    };

    Unpacker.prototype.u = function() {
      var mode, ret, _ref1;
      mode = modes.START;
      while (mode !== modes.NONE) {
        _ref1 = this.u_inner(mode), mode = _ref1[0], ret = _ref1[1];
      }
      return ret;
    };

    return Unpacker;

  })();

  exports.unpack = function(x, enc) {
    var err, res, unpacker, warn;
    if (enc == null) enc = 'base64';
    unpacker = new Unpacker;
    err = null;
    res = null;
    if (unpacker.decode(x, enc)) {
      res = unpacker.u();
      err = unpacker.get_error();
      warn = unpacker.get_warning();
    } else {
      err = "Decoding type '" + enc + "' failed";
    }
    return [err, res, warn];
  };

}).call(this);
